const { app, BrowserWindow, clipboard, ipcMain } = require('electron');
const path = require('path');

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Vite plugin.
declare const MAIN_WINDOW_VITE_DEV_SERVER_URL: string;
declare const MAIN_WINDOW_VITE_NAME: string;

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 800,
    width: 1200,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      nodeIntegration: false,
      contextIsolation: true,
    },
    show: false, // Don't show until ready
  });

  // Show window when ready to prevent white flash
  mainWindow.once('ready-to-show', () => {
    mainWindow.show();
    
    // Open DevTools in development
    if (process.env.NODE_ENV === 'development') {
      mainWindow.webContents.openDevTools();
    }
  });

  // Store reference for clipboard monitoring
  let lastClipboardContent = '';
  let clipboardMonitor: NodeJS.Timeout | null = null;

  // Clipboard monitoring function
  const startClipboardMonitoring = () => {
    clipboardMonitor = setInterval(() => {
      const currentContent = clipboard.readText();
      if (currentContent && currentContent !== lastClipboardContent) {
        lastClipboardContent = currentContent;
        // Send to renderer process
        mainWindow.webContents.send('clipboard-change', currentContent);
      }
    }, 500); // Check every 500ms
  };

  // Stop monitoring when window is closed
  mainWindow.on('closed', () => {
    if (clipboardMonitor) {
      clearInterval(clipboardMonitor);
    }
  });

  // IPC handlers for clipboard operations
  ipcMain.handle('get-clipboard', () => {
    return clipboard.readText();
  });

  ipcMain.handle('set-clipboard', (_event: any, text: string) => {
    clipboard.writeText(text);
    lastClipboardContent = text; // Update to prevent self-trigger
    return true;
  });

  ipcMain.handle('start-clipboard-monitoring', () => {
    startClipboardMonitoring();
    return true;
  });

  ipcMain.handle('stop-clipboard-monitoring', () => {
    if (clipboardMonitor) {
      clearInterval(clipboardMonitor);
      clipboardMonitor = null;
    }
    return true;
  });

  // and load the index.html of the app.
  if (MAIN_WINDOW_VITE_DEV_SERVER_URL) {
    console.log('Loading development URL:', MAIN_WINDOW_VITE_DEV_SERVER_URL);
    mainWindow.loadURL(MAIN_WINDOW_VITE_DEV_SERVER_URL);
  } else {
    // In production, load from the renderer directory
    console.log('Production mode - __dirname:', __dirname);
    console.log('MAIN_WINDOW_VITE_NAME:', MAIN_WINDOW_VITE_NAME);
    
    // Try multiple possible paths for the renderer
    const possiblePaths = [
      path.join(__dirname, `../renderer/${MAIN_WINDOW_VITE_NAME}/index.html`),
      path.join(__dirname, '../renderer/main_window/index.html'),
      path.join(__dirname, '../renderer/index.html'),
      path.join(process.resourcesPath, 'app/.vite/renderer/main_window/index.html'),
      path.join(process.resourcesPath, 'app/dist/renderer/index.html')
    ];
    
    let loadedSuccessfully = false;
    for (const filePath of possiblePaths) {
      try {
        const fs = require('fs');
        if (fs.existsSync(filePath)) {
          console.log('Found renderer file at:', filePath);
          mainWindow.loadFile(filePath).then(() => {
            loadedSuccessfully = true;
          }).catch((error: any) => {
            console.log('Failed to load found file:', filePath, error);
          });
          break;
        } else {
          console.log('File does not exist:', filePath);
        }
      } catch (error) {
        console.log('Failed to load:', filePath, error);
      }
    }
    
    if (!loadedSuccessfully) {
      console.error('Could not find renderer file in any expected location');
      console.log('Available files in __dirname:', require('fs').readdirSync(__dirname));
      console.log('Available files in parent:', require('fs').readdirSync(path.join(__dirname, '..')));
    }
  }

  // Add error handling for renderer process crashes
  mainWindow.webContents.on('crashed', () => {
    console.error('Renderer process crashed');
  });

  mainWindow.webContents.on('unresponsive', () => {
    console.error('Renderer process became unresponsive');
  });

  mainWindow.webContents.on('did-fail-load', (_event: any, errorCode: number, errorDescription: string, validatedURL: string) => {
    console.error('Failed to load page:', errorCode, errorDescription, validatedURL);
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
